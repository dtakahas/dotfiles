{"mode":"editor","version":"0.73.0","windowDimensions":{"x":0,"y":22,"width":1920,"height":1054},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/davidtakahashi/policy_builder","buffers":[{"text":"=builder_form do |fp, f|\n  %h3 Trip Transit\n  .im_classes_forms.well\n    =f.fields_for :im_classes, f.object.im_classes.trip_transit do |fc|\n      .row.form-horizontal\n        .span5\n          =fc.input :premium, as: :premium, wrapper: :prepend, required: true\n          =fc.input :coinsurance_percent, as: :percentage, wrapper: :append\n        .span5\n          -fc.object.build_deductibles!\n          =fc.fields_for :im_deductibles, fc.object.im_deductibles.sort_by(&:code) do |fl|\n            =fl.input :policy_version_id, as: :hidden, input_html: {value: f.object.id}\n            =fl.input :code, as: :hidden\n            =fl.input :amount, as: :limit, wrapper: :prepend, label: fl.object.name\n          -fc.object.build_limits!\n          =fc.fields_for :im_limits, fc.object.im_limits.sort_by(&:code) do |fl|\n            =fl.input :policy_version_id, as: :hidden, input_html: {value: f.object.id}\n            =fl.input :code, as: :hidden\n            =fl.input :amount, as: :limit, wrapper: :prepend, label: fl.object.name\n\n  .im_trip_transits_forms\n    =f.fields_for :im_trip_transits do |ff|\n      =render 'builder/im_trip_transit_fields', f: ff\n  .row\n    .span12=link_to_add_fields 'Add Coverage', f, :im_trip_transits, \"form\", \".im_trip_transits_forms\", class:'btn btn-success btn-mini pull-left'","markers":{"markers":{"1":{"id":1,"range":[[24,4],[24,4]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":61,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/davidtakahashi/policy_builder/app/views/builder/im_trip_transit.html.haml","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6a2784739e17a3c6269d306a06408a5656fd24ea","deserializer":"TextBuffer"},{"text":"=builder_form do |fp, f|\n  %h3 Contractor's Equipment\n  .im_classes_forms.well\n    =f.fields_for :im_classes, f.object.im_classes.contractors_equipment do |fc|\n      .row.form-horizontal\n        .span5\n          =fc.input :premium, as: :premium, wrapper: :prepend, required: true\n          =fc.input :coinsurance_percent, as: :percentage, wrapper: :append\n          -fc.object.build_deductibles!\n          =fc.fields_for :im_deductibles, fc.object.im_deductibles.sort_by(&:code) do |fl|\n            =fl.input :policy_version_id, as: :hidden, input_html: {value: f.object.id}\n            =fl.input :code, as: :hidden\n            =fl.input :amount, as: :limit, wrapper: :prepend, label: fl.object.name\n        .span5\n          -fc.object.build_limits!\n          =fc.fields_for :im_limits, fc.object.im_limits.sort_by(&:code) do |fl|\n            =fl.input :policy_version_id, as: :hidden, input_html: {value: f.object.id}\n            =fl.input :code, as: :hidden\n            =fl.input :amount, as: :limit, wrapper: :prepend, label: fl.object.name\n          \n  .im_contractors_equipments_forms\n    =f.fields_for :im_contractors_equipments do |ff|\n      =render 'builder/im_contractors_equipment_fields', f: ff\n\n  .row\n    .span12=link_to_add_fields 'Add Equipment', f, :im_contractors_equipments, \"form\", \".im_contractors_equipments_forms\", class:'btn btn-success btn-mini pull-left'","markers":{"markers":{"1":{"id":1,"range":[[15,0],[15,0]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":69,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/davidtakahashi/policy_builder/app/views/builder/im_contractors_equipment.html.haml","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"aa6f3419f271c3b0d5f35aaf12ed742689988ec3","deserializer":"TextBuffer"},{"text":"class ImClass < ActiveRecord::Base\n  default_scope order(\"#{table_name}.id asc\")\n  include Mixins::HasParent\n  attr_protected :policy_version_id, :created_at, :updated_at\n  belongs_to :policy_version, inverse_of: :im_classes\n  has_many :im_limits, dependent: :destroy\n  has_many :im_deductibles, dependent: :destroy\n  accepts_nested_attributes_for :im_limits\n  accepts_nested_attributes_for :im_deductibles\n  before_destroy :destroy_receptacles\n  # We are currently not destroying all schedule items, just receptacles.\n\n  # Limits and deductibles in this hash are class level. \n  # Schedule item level limits and deductibles will be listed in the schedule item model.\n  CLASS_CODE_DATA = {\n    accounts_receivable:{\n      class_code: 'AccountsReceivable',\n      coverage_code: 'ACCTS',\n      name: \"Accounts Receivable\",\n      limits: %w[\n        AtLocation\n        AwayFromLocation\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [:im_accounts_receivables],\n    },\n    bailees_articles: {\n      class_code: 'CommlArticles',\n      coverage_code: 'BAIFL',\n      name: \"Bailees Articles\",\n      limits: %w[\n        AtLocation\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [:im_bailees_articles],\n    },\n    # builders_risk: {\n    #   class_code: 'BLDRK',\n    #   coverage_code: 'OT',\n    #   name: \"Builder's Risk\",\n    #   limits: %w[\n    #     PerOccurrence\n    #     PropertyInTransit\n    #     PropertyInTemporaryStorage\n    #   ],\n    #   schedules: [],\n    # },\n    contractors_equipment: {\n      class_code: 'ContractorsEquipment',\n      coverage_code: 'CONEQ',\n      name: \"Contractor's Equipment\",\n      limits: %w[\n        PerItem\n        LeasedShortTerm\n        LeasedLongTerm\n      ],\n      deductibles: %w[\n        PerItem\n        PerOccurrence\n        ],\n      schedules: [\n        :im_contractors_equipments\n      ],\n    },\n    edp: {\n      class_code: 'EDP',\n      coverage_code: 'EDP',\n      name: \"Electronic Data Protection\",\n      limits: %w[\n        AtLocation\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_data_protections\n      ],\n    },\n    exhibition: {\n      class_code: 'CommlArticles',\n      coverage_code: 'EXBFL',\n      name: \"Exhibition\",\n      limits: %w[\n        PerOccurrence\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_exhibitions\n      ],\n    },\n    installation: {\n      class_code: 'Installation',\n      coverage_code: 'INSTL',\n      name: \"Installation\",\n      limits: %w[\n        AtAnyOneJobsite\n        AtAnyLocationOtherThanJobsite\n        PropertyInTransit\n        PerOccurrence\n      ],\n      deductibles: %w[\n        AllOth\n        ],\n      schedules: [\n        :im_installations\n        ],\n    },\n    # misc_articles:{\n    #   class_code: 'MiscArticles',\n    #   coverage_code: 'OT',\n    #   name: \"Miscellaneous Articles\",\n    #   limits: %w[\n    #     PerOccurrence\n    #   ],\n    #   schedules: [\n    #     :im_articles,\n    #   ],\n    # },\n    scheduled_property: {\n      class_code: 'MiscArticles',\n      coverage_code: 'MIAOP',\n      name: \"Scheduled Property\",\n      limits: %w[\n        PerItem\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_scheduled_properties\n      ],\n    },\n    # transportation:{\n    #   class_code: 'Transportation',\n    #   coverage_code: 'TRANS',\n    #   name: \"Motor Truck Cargo\",\n    #   limits: %w[\n    #     AnyOneLoss\n    #   ],\n    #   schedules: [\n    #     :im_vehicles\n    #   ],\n    # },\n    # riggers: {\n    #   class_code: 'CommlArticles',\n    #   coverage_code: 'OT',\n    #   name: \"Riggers Legal Liability\",\n    #   limits: %w[\n    #     PerOccurrence\n    #     PropertyInTransit\n    #     AnyOneLoss\n    #   ],\n    #   schedules: [],\n    # },\n    signs: {\n      class_code: 'MiscArticles',\n      coverage_code: 'SIGN',\n      name: \"Signs\",\n      limits: %w[\n        PerItem\n        ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_signs\n        ],\n    },\n    # tools: {\n    #   class_code: 'Tools',\n    #   coverage_code: 'TOOLS',\n    #   name: \"Tools\",\n    #   limits: %w[\n    #     PerOccurrence\n    #     ],\n    #   schedules: [],\n    # },\n    trip_transit: {\n      class_code: 'Transportation',\n      coverage_code: 'TRPTR',\n      name: \"Trip Transit\",\n      limits: %w[\n        AtAllLocations\n        ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_trip_transits\n        ],\n    },\n    valuable_papers: {\n      class_code: 'ValuablePapers',\n      coverage_code: 'PAPER',\n      name: \"Valuable Papers\",\n      limits: %w[\n        AtLocation\n        AwayFromLocation\n      ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [\n        :im_valuable_papers\n      ],\n    },\n    warehousemens: {\n      class_code: 'CommlArticles',\n      coverage_code: 'BAILE',\n      name: \"Warehousemen's Legal Liability\",\n      limits: %w[\n        AtLocation\n        ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [:im_warehousemens_bailees_articles],\n    },\n    watercraft: {\n      class_code: 'Transportation',\n      coverage_code: 'HULL',\n      name: \"Watercraft Physical Damage\",\n      limits: %w[\n        PerItem\n        ],\n      deductibles: %w[\n        PerOccurrence\n        ],\n      schedules: [:im_watercrafts],\n    }\n  }.stringify_keys\n\n  CLASSES = Hash[CLASS_CODE_DATA.map{|k, v| [k, v[:name]] }]\n\n  validates :short_name, presence: true, inclusion: CLASS_CODE_DATA.keys\n\n  def short_name_sym\n    :\"im_#{short_name}\"\n  end\n\n  def name\n    class_code_data :name, \"Unknown Class\"\n  end\n\n  def class_code\n    class_code_data :class_code\n  end\n\n  def coverage_code\n    class_code_data :coverage_code\n  end\n\n  def class_code_description\n    name\n  end\n\n  def limit_codes_for_class\n    class_code_data :limits, []\n  end\n\n  def deductible_codes_for_class\n    class_code_data :deductibles, []\n  end\n\n  def schedule?\n    class_code_data(:schedules, []).present?\n  end\n\n  def schedule\n    relation = class_code_data(:schedules, []).first\n    return [] unless relation\n    policy_version.respond_to?(relation) && policy_version.send(relation)\n  end\n\n  def build_limits!\n    # limits\n    current_codes = im_limits.map(&:code)\n    supported_codes = limit_codes_for_class\n    (supported_codes - current_codes).each{|code| im_limits.build(code: code) }\n  end\n\n  def build_deductibles!\n    # deductibles\n    current_codes = im_deductibles.map(&:code)\n    supported_codes = deductible_codes_for_class\n    (supported_codes - current_codes).each{|code| im_deductibles.build(code: code) }\n  end\n\n  def self.guess_short_name_from_codes(class_code, coverage_code)\n    id = CLASS_CODE_DATA.find{|k, v| \n      v[:class_code] == class_code && \n      # If coverage_code is nil, the first coverage can be any code\n      (v[:coverage_code].nil? || v[:coverage_code] == coverage_code)\n    }\n    id, v = id\n    (v || {}).merge({:short_name => id})\n  end\n\n  protected\n  def class_code_data(member = nil, default = nil)\n    data =  CLASS_CODE_DATA[short_name]\n    member ? data.try(:[], member) || default : data\n  end\n\n  def destroy_receptacles\n    # Must be destroyed to prevent error in policy_reader when the parent class is destroyed\n    if short_name == \"accounts_receivable\"\n      policy_version.im_ar_receptacles.each(&:destroy)\n    elsif short_name == \"valuable_papers\"\n      policy_version.im_vp_receptacles.each(&:destroy)\n    elsif short_name == \"exhibition\"\n      policy_version.im_exhibition_receptacles.each(&:destroy)\n    end\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":71,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"oldRange":[[0,8],[0,9]],"newRange":[[0,8],[0,8]],"oldText":"t","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,7],[0,8]],"newRange":[[0,7],[0,7]],"oldText":"i","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,6],[0,7]],"newRange":[[0,6],[0,6]],"oldText":"m","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,5],[0,6]],"newRange":[[0,5],[0,5]],"oldText":"i","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,4],[0,5]],"newRange":[[0,4],[0,4]],"oldText":"l","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,3],[0,4]],"newRange":[[0,3],[0,3]],"oldText":"_","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,2],[0,3]],"newRange":[[0,2],[0,2]],"oldText":"m","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,1],[0,2]],"newRange":[[0,1],[0,1]],"oldText":"i","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[0,0],[0,1]],"newRange":[[0,0],[0,0]],"oldText":"T","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"properties":{"type":"selection","editorId":71,"goalBufferRange":null},"range":[[0,0],[0,0]]},"newParams":{"properties":{"type":"selection","editorId":71},"range":[[0,0],[0,0]]},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/davidtakahashi/policy_builder/app/models/im_class.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"06e1ba669de57e69844a7d79f2750f2144f7a7f8","deserializer":"TextBuffer"},{"text":"class ImLimit < ActiveRecord::Base\n  include Mixins::HasParent\n  default_scope order(\"#{table_name}.id asc\")\n  attr_protected :im_class_id, :im_schedule_item_id, :created_at, :updated_at\n  belongs_to :im_class, inverse_of: :im_limits\n  belongs_to :im_schedule_item, inverse_of: :im_limits\n  after_save {|limit| limit.destroy if limit.amount.blank?}\n  \n  CODE_DATA = {\n    # General Limits\n    PerOccurrence: {\n      name: 'Limit Per Occurrence',\n      applies_to: 'PerOcc',\n    },\n    PerItem: {\n      name: 'Limit Per Item',\n      applies_to: 'PerItem',\n    },\n    PropertyInTransit: {\n      name: 'Limit for Property in Transit',\n      applies_to: 'PropertyInTransit',\n    },\n    PropertyInTemporaryStorage: {\n      name: 'Limit for Property In Temporary Storage',\n      applies_to: 'PropertyInTemporaryStorage',\n    },\n    AtAnyOneJobsite: {\n      name: 'Limit at Any One Jobsite',\n      applies_to: 'AnyOneJobSite',\n    },\n    AnyOneLoss: {\n      name: 'Limit Any One Loss',\n      applies_to: 'PerLoss',\n    },\n    AwayFromLocation: {\n      name: 'Limit Away From Location',\n      applies_to: 'AwayFromPremises',\n    },\n    AllOtherCoveredProperty: {\n      name: 'Limit for All Other Covered Property',\n      applies_to: 'Other',\n    },\n    AtAnyLocationOtherThanJobsite: {\n      name: 'Limit at any Location Other than Jobsite',\n      applies_to: 'AnyLocationOtherThanJobSite',\n    },\n    AtLocation: {\n      name: 'Limit at Location',\n      applies_to: 'YourPremises',\n    },\n    AtAllLocations: {\n      name: 'Limit at all Locations',\n      applies_to: 'AllCoveredProperty',\n    },\n    AnyOneUnnamedPremises: {\n      name: 'Limit at any one unnamed premises',\n      applies_to: 'AnyOneUnnamedPremises',\n    },\n    # EDP Limits\n    EDP_InTransit: {\n      name: 'Limit for Equipment in Transit',\n      applies_to: 'PropertyInTransit',\n      coverage_code: 'EDPIN',\n    },\n    EDP_Hardware: {\n      name: 'Limit for Hardware',\n      applies_to: 'AnyOneUnnamedPremises',\n      coverage_code: 'EDPPP',\n    },\n    EDP_Software: {\n      name: 'Limit for Software',\n      applies_to: 'AnyOneUnnamedPremises',\n      coverage_code: 'EDPMD',\n    },\n    EDP_Communication: {\n      name: 'Limit for Communication Systems',\n      applies_to: 'AnyOneUnnamedPremises',\n      coverage_code: 'EDPCM',\n    },\n    EDP_Protection: {\n      name: 'Limit for Protection or Control Systems',\n      applies_to: 'AnyOneUnnamedPremises',\n      coverage_code: 'EDPPC',\n    },\n    EDP_Extra: {\n      name: 'Limit for Extra Expense',\n      applies_to: 'AnyOneUnnamedPremises',\n      coverage_code: 'EE',\n    },\n    # Installation Limits\n    InstallationSoftCost: {\n      name: 'Soft Cost Limit',\n      applies_to: 'PerOcc',\n      coverage_code: 'SOFTC',\n    },\n    InstallationWaterDamage: {\n      name: 'Water Damage Limit',\n      applies_to: 'PerOcc',\n      coverage_code: 'WDE',\n    },\n    # Constractors Equipment Limits\n    LeasedShortTerm: {\n      name: 'Limit for Leased or Rented Equipment (up to 3 months)',\n      applies_to: 'LeasedShortTerm',\n    },\n    LeasedLongTerm: {\n      name: 'Limit for Leased or Rented Equipment (over 3 months)',\n      applies_to: 'LeasedLongTerm',\n    },\n    # Valuable Papers Limits\n    VP_AwayFromLocation: {\n      name: 'Limit for Property Away From Location',\n      applies_to: 'AwayFromPremises',\n      coverage_code: 'VPAOL',\n    },\n    VP_Other: {\n      name: 'Limit for All Other Covered Property',\n      applies_to: 'Other',\n      coverage_code: 'OT',\n    },\n  }.stringify_keys\n\n  CODES = Hash[CODE_DATA.map{|k, v| [k, v[:name]] }]\n\n  def name\n    CODES[code]\n  end\n\n  def code_description\n    CODE_DATA[code].try(:[],:name)\n  end\n\n  def applies_to_code\n    CODE_DATA[code].try(:[],:applies_to)\n  end\n\n  def coverage_code\n    CODE_DATA[code].try(:[], :coverage_code) || im_class.coverage_code\n  end\n\n  def self.guess_short_name_from_codes(applies_to, coverage_code, default_coverage_code)\n    coverage_code = nil if coverage_code == default_coverage_code\n    id = CODE_DATA.find{|k, v| \n      v[:applies_to] == applies_to && \n      v[:coverage_code] == coverage_code\n    }\n    id, v = id\n    (v || {}).merge({:short_name => id})\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[112,35],[112,35]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":73,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"oldRange":[[16,19],[16,25]],"newRange":[[16,19],[16,26]],"oldText":"PerOcc","newText":"PerItem","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":false,"range":[[16,26],[16,26]]},"newParams":{"tailed":true,"range":[[16,19],[16,26]]},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/davidtakahashi/policy_builder/app/models/im_limit.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"badc745918068e7621e0272d0cbae8f10f7db106","deserializer":"TextBuffer"},{"text":"module Acord\nclass PolicyReader\n  attr_reader :xml, :xml_errors, :service_request, :sign_on_request, :vpi_extensions\n\n  # VPI Mode tells the reader to attempt to match up database records with the \n  # xml so the data can be imported without deleting stuff out of the database.\n  #\n  # For this to work, the order of the elements in the xml needs to match the\n  # order records are returned from the database. \n  attr_reader :vpi_mode\n\n  # Allow endorsement processing. \n  # Currently VPB does not support new endorsements so endorsement_mode is only \n  # available if vpi_mode is enabled.\n  attr_reader :endorsement_mode\n\n  LINE_DATA = {}\n  # LINE_DATA Structure, master list of supported lines is in LineOfBusiness model\n  #  {\n  #   \"CommlPkgPolicyAddRq\" => {\n  #     lob_codes:   [\"CPKGE\"],\n  #     pc_policy:   \"CommlPolicy\",\n  #     lines: {\n  #       'GeneralLiabilityLineBusiness' => {\"CGL\" => 'gl'}, # line_node =>  {lob_code => short_name}\n  #     }\n  #   },\n  #   --snip--\n  # }\n\n\n  LineOfBusiness::LINE_DATA.each do |k, v|\n    service_request_data = LINE_DATA[v[:service_request]] ||= {\n      lob_codes: [], # maps \"CGL\" => 'gl'\n      lines: {}, # available LineBusiness nodes\n      pc_policy: \"CommlPolicy\",\n    }\n    service_request_data[:lob_codes] << v[:lob_code]\n\n    processor = ->(short_name, line_data){\n      k = line_data[:lob_node]\n      service_request_data[:lines][k] ||= {}\n      service_request_data[:lines][k][line_data[:lob_code]] = short_name\n    } \n    if package = v[:package_of]\n      package.each do |line|\n        processor[line, LineOfBusiness::LINE_DATA[line]]\n      end\n    else\n      processor[k, v]\n    end\n  end\n\n  # Allow mod requests to work as if they are policies\n  LINE_DATA.keys.each do |k|\n    mod_req = k.gsub(/AddRq$/, \"ModRq\")\n    LINE_DATA[mod_req] = LINE_DATA[k]\n  end\n\n  VALID_REQUESTS = LINE_DATA.keys\n\n  # Can raise Acord::Exceptions::PolicyException\n  def initialize(user, xml_or_string, options={})\n    options = {\n      vpi_mode: false,\n      endorsement_mode: false,\n    }.update options\n    @vpi_mode = options[:vpi_mode]\n    @endorsement_mode = options[:endorsement]\n    @user = user\n    case xml_or_string\n    when String, IO\n      begin\n        @xml = Nokogiri::XML::Document.parse(xml_or_string, nil, nil, Nokogiri::XML::ParseOptions::STRICT)\n      rescue Nokogiri::XML::SyntaxError => e\n        raise Acord::Exceptions::PolicyException, \"Invalid xml document: #{e.message}\"\n      end\n    when Nokogiri::XML::Document\n      @xml = xml_or_string\n    else\n      raise ArgumentError, \"Unknown input to AcordReader: #{xml_or_string.inspect}\"\n    end\n\n    error! \"New endorsement processing is not implemented.\" if !vpi_mode && endorsement_mode\n    @buildings = {}\n    validate_xml\n    load_top_nodes_and_validate\n    strip_deleted_nodes if @endorsement_mode\n    load_lines_of_business\n  end\n\n  def load_top_nodes_and_validate\n    @sign_on_request = XmlNode.node(@xml.root, '/ACORD/SignonRq') \n    @vpi_extensions =  XmlNode.node(@xml.root, '/ACORD/VertaforeExtensions/VPI') \n    error! \"Missing InsuranceSvcRq\"                unless @policy_body = XmlNode.node(@xml.root, '/ACORD/InsuranceSvcRq') \n    error! \"Missing or unsupported request type\"   unless @service_request = @policy_body.node(*VALID_REQUESTS)\n    error! \"ModRq not supported on this webservice.\" if @service_request.name =~ /ModRq/ && !endorsement_mode\n    error! \"AddRq not supported on this webservice.\" if @service_request.name =~ /AddRq/ && endorsement_mode\n    data = LINE_DATA[@service_request.name]\n    error! \"Missing PC_POLICY node\"                unless @pc_policy = @service_request.node('CommlPolicy')\n    error! \"Missing NAIC Code.\"                    unless naic = @pc_policy.string('NAICCd').presence\n    error! \"User is not authorized for NAIC Code.\" unless @user.approved_for_naic?(naic)\n    error! \"General Agent is not authorized for NAIC Code.\" unless @user.general_agent.approved_for_naic?(naic)\n    @lob_code = @pc_policy.string('LOBCd')\n    error! \"Missing LOB Code.\"                     unless @lob_code.present?\n    error! \"Unsupported or mismatched LOB Code: \\\"#{@lob_code}\\\"\" unless data[:lob_codes].include?(@lob_code)\n    error! \"Missing policy guid\"                   unless @service_request.string('ItemIdInfo/SystemId').present?\n    error! \"Missing policy number\"                 unless @pc_policy.string('PolicyNumber').present?\n    error! \"Missing or malformed effective date\"   unless effective = @pc_policy.date('ContractTerm/EffectiveDt')\n    error! \"Missing or malformed expiration date\"  unless expires = @pc_policy.date('ContractTerm/ExpirationDt')\n    error! \"Expiration date is before effective date.\" unless effective < expires\n    @insured = @service_request.node('InsuredOrPrincipal[InsuredOrPrincipalInfo/InsuredOrPrincipalRoleCd=\"Insured\"]')\n    @general_agent = @service_request.node('Producer[ProducerInfo/ProducerRoleCd=\"Intermediary\"]')\n    @retail_agent = @service_request.node('Producer[ProducerInfo/ProducerRoleCd=\"Agency\"]')\n  end\n\n  def strip_deleted_nodes\n    @service_request.array('ModInfo[ActionCd=\"D\"]').each do |mod|\n      node = @service_request.node(\"//*[@id=\\\"#{mod.id_ref}\\\"]\")\n      node.nokogiri_node.remove if node\n    end\n  end\n\n  def load_lines_of_business\n    # This xpath does a /LineBusiness$/ match on node names. \n    @lob_nodes = @service_request.array(\"*[substring(name(), string-length(name()) - 11) = 'LineBusiness']\")\n    error! \"No Line of Business Data\" if @lob_nodes.empty?\n    data = LINE_DATA[@service_request.name]\n    @lobs = {}\n    @lob_nodes.each do |node| \n      error! \"Unsupported tag: \\\"#{node.name}\\\" for LOB Code: \\\"#{@lob_code}\\\"\" unless data[:lines].keys.include? node.name \n      lob = node.string('LOBCd')\n      error! \"Unsupported LOB Code: \\\"#{lob}\\\" for \\\"#{node.name}\\\"\" unless data[:lines][node.name].keys.include?(lob)\n      lob_short_name = data[:lines][node.name][lob]\n      lob_premium = node.string('CurrentTermAmt/Amt') || 0\n      @lobs[lob_short_name] = lob_premium\n    end\n  end\n\n  def to_policy\n    guid = @service_request.string(\"ItemIdInfo/SystemId\")\n    policy = Policy.for_acord_reader(@user, guid)\n    endorsement = policy.new_record? ? nil : policy.latest_pending_endorsement\n\n    if policy.general_agent != @user.general_agent\n      error! \"This policy's guid belongs to another General Agent.\"\n    end\n\n    unless endorsement_mode\n      error! \"This policy has already been mailed out.\" unless policy.can_edit? \n    else\n      error! \"No pending endorsement to apply changes to.\" unless endorsement\n    end\n    \n\n    Policy.transaction do\n      unless endorsement_mode\n        policy.assign_attributes({\n          policy_number:      @pc_policy.string('PolicyNumber'),\n          carrier_naic:       @pc_policy.string('NAICCd'),\n          effective_at:       @pc_policy.date('ContractTerm/EffectiveDt'),\n          expires_at:         @pc_policy.date('ContractTerm/ExpirationDt'),\n        }, without_protection: true)\n      end\n\n      policy.latest_policy_version.assign_attributes({\n          policy_number:      @pc_policy.string('PolicyNumber'),\n          effective_at:       @pc_policy.date('ContractTerm/EffectiveDt'),\n          expires_at:         @pc_policy.date('ContractTerm/ExpirationDt'),\n          status:             PolicyVersion::STATUS_ACORD_CODES.invert[@pc_policy.string('PolicyStatusCd')] || 'new',\n          renewal_of_number:  @pc_policy.string('OtherOrPriorPolicy[PolicyCd=\"Prior\"]/PolicyNumber'),\n          program_code:       @pc_policy.string('CompanyProductCd'),\n          minimum_premium:    @pc_policy.string('MinPremAmt/Amt'),\n          audit_code:         @pc_policy.string('CommlPolicySupplement[AuditInd=\"1\"]/AuditFrequencyCd'),\n          terrorism_code:     @pc_policy.string('CommlCoverage[1]/CoverageCd'),\n          terrorism_premium:  @pc_policy.string('CommlCoverage[1]/CurrentTermAmt/Amt'),\n          tax_state:          @insured.try(:string, 'GeneralPartyInfo/NameInfo/TaxIdentity/StateProvCd'),\n      }, without_protection: true)\n     \n      if vpi_mode && endorsement_mode\n        begin\n          endorsement.assign_attributes({\n            premium: @pc_policy.string('NetChangeAmt/Amt')\n          }, without_protection: true)\n          endorsement.save!(validate: false)\n        rescue\n          nil\n        end\n      end\n           \n      if vpi_mode || endorsement_mode\n        policy.save!(validate: false)\n      elsif (available, msg = policy.policy_number_available?).first\n        policy.save!(validate: false)\n      else\n        error! msg\n      end\n\n      policy_version = policy.latest_policy_version\n\n      CustomField.where(policy_version_id: policy_version.id).delete_all\n      RemovePolicyForm.where(policy_version_id: policy_version.id).delete_all\n\n      if @vpi_extensions\n        @vpi_extensions.array('Custom/Item').map do |node|\n          next unless value = node.string('Value') # remove empty custom fields so the database constraints don't get cranky\n          policy_version.custom_fields.create!(name: node.string('Name'), value: value)\n        end\n        @vpi_extensions.array('RemoveForm').map do |node|\n          next unless name = node.string('FormNumber')\n          policy_version.remove_policy_forms.create!(name: name)\n        end\n      end\n\n      AddPolicyForm.where(policy_version_id: policy_version.id).delete_all\n      @pc_policy.array('Form').map do |node|\n        next unless name = node.string('FormNumber')\n        policy_version.add_policy_forms.create!(name: name)\n      end\n\n      if vpi_mode\n        PolicyForm.where(policy_version_id: policy_version.id).delete_all \n        @vpi_extensions.array('Forms/Form').map do |node|\n          policy_version.policy_forms.create!(\n            name:                  node.string('Name'),\n            vpi_id:                node.number('FormId'),\n            category:              node.string('Category'),\n            title:                 node.string('Title'),\n            sequence:              node.number('Sequence'),\n            state:                 node.string('State'),\n            version:               node.string('Version'),\n            vpi_version_id:        node.number('VersionId'),\n            effective_date:        node.string('EffectiveDate'),\n            tags:                  node.string('Tags'),\n            exclude_from_schedule: node.bool('ExcludeFromScheduleOfForms'),\n            skip_print:            node.bool('SkipPrint'),\n            overflow_for:          node.string('OverflowFor')\n          )\n        end\n      end\n\n      if @insured\n        policy_version.build_insured unless policy_version.insured\n        policy_version.insured.assign_attributes({\n          name:             @insured.string('GeneralPartyInfo/NameInfo/CommlName/CommercialName'),\n          dba_name:         @insured.string('GeneralPartyInfo/NameInfo/SupplementaryNameInfo[SupplementaryNameCd=\"DBA\"]/SupplementaryName'),\n          form_of_business: @insured.string('GeneralPartyInfo/NameInfo/LegalEntityCd'),\n          phone:            @insured.string('GeneralPartyInfo/Communications/PhoneInfo[PhoneTypeCd=\"Phone\"]/PhoneNumber'),\n          email:            @insured.string('GeneralPartyInfo/Communications/EmailInfo/EmailAddr'),\n          sic_code:         @insured.string('InsuredOrPrincipalInfo/BusinessInfo/SICCd'),\n          business_description: @insured.string('InsuredOrPrincipalInfo/BusinessInfo/OperationsDesc'),\n        }, without_protection: true)\n        policy_version.insured.save!(validate: false)\n        set_mailing_address(policy_version.insured, @insured.address('GeneralPartyInfo'))\n      end\n\n      if @retail_agent\n        policy_version.build_retail_agent unless policy_version.retail_agent\n        policy_version.retail_agent.assign_attributes({\n          name:       @retail_agent.string('GeneralPartyInfo/NameInfo/CommlName/CommercialName'),\n          agent_code: @retail_agent.string('ItemIdInfo/InsurerId'),\n          phone:      @retail_agent.string('GeneralPartyInfo/Communications/PhoneInfo[PhoneTypeCd=\"Phone\"]/PhoneNumber'),\n          email:      @retail_agent.string('GeneralPartyInfo/Communications/EmailInfo/EmailAddr'),\n        }, without_protection: true)\n        policy_version.retail_agent.save!(validate: false)\n        set_mailing_address(policy_version.retail_agent, @retail_agent.address('GeneralPartyInfo'))\n      end\n      \n      if @general_agent\n        policy_version.build_general_agent unless policy_version.general_agent\n        policy_version.general_agent.assign_attributes({\n          name:                  @general_agent.string('GeneralPartyInfo/NameInfo/CommlName/CommercialName'),\n          agent_code:            @general_agent.string('ItemIdInfo/InsurerId'),\n          surplus_lines_license: @general_agent.string('ProducerInfo/License/LicensePermitNumber'),\n          phone:                 @general_agent.string('GeneralPartyInfo/Communications/PhoneInfo[PhoneTypeCd=\"Phone\"]/PhoneNumber'),\n          email:                 @general_agent.string('GeneralPartyInfo/Communications/EmailInfo/EmailAddr'),\n        }, without_protection: true)\n        policy_version.general_agent.save!(validate: false)\n        set_mailing_address(policy_version.general_agent, @general_agent.address('GeneralPartyInfo'))\n      end\n\n      read_in_array(policy_version.tax_fees, @pc_policy.array(\"CommlPolicySupplement/CreditOrSurcharge\")) do |obj, node|\n        {\n          code: node.string('CreditSurchargeCd'),\n          code_name: node.string('CreditSurchargeAmtDesc'),\n          amount: node.string('NumericValue/FormatCurrencyAmt/Amt'),\n          type_code: node.string('SecondaryCd'),\n        }\n      end\n\n      read_additional_interests(policy_version, @pc_policy.array('AdditionalInterest'), nil)\n\n      read_in_array(policy_version.locations, @service_request.array('Location')) do |location, location_node|\n        location.assign_attributes({\n          number:             location_node.string('ItemIdInfo/AgencyId'),\n          name:               location_node.string('LocationName'),\n          description:        location_node.string('LocationDesc'),\n          address_attributes: {\n            address_type:     \"mailing\",\n            address1:         location_node.string(\"Addr/Addr1\"),\n            address2:         location_node.string(\"Addr/Addr2\"),\n            city:             location_node.string(\"Addr/City\"),\n            state:            location_node.string(\"Addr/StateProvCd\"),\n            zipcode:          location_node.string(\"Addr/PostalCode\"),\n            county:           location_node.string(\"Addr/County\"),\n          },\n        }, without_protection: false) \n        location.save!(validate: false)\n\n        read_in_array(location.buildings, location_node.array('SubLocation'), false) do |building, building_node|\n          @buildings[building_node.id] = building\n          building.assign_attributes({\n            number: building_node.string('ItemIdInfo/AgencyId'),\n            name:   building_node.string('SubLocationName'),\n            description: building_node.string('SubLocationDesc')\n          }, without_protection: true)\n          building.save!(validate: false)\n\n          if detail_node = @service_request.node(\"CommlSubLocation[@SubLocationRef=\\\"#{building_node.id}\\\" and not(SafeVaultCharacteristics) and not(ContractEffectiveDt)]\") \n            detail = building.building_detail || building.build_building_detail(policy_version: policy_version)\n            occupancy_code = detail_node.string('BldgOccupancy[VacantUnoccupiedCd=\"VAC\"]/VacantUnoccupiedCd')\n            occupancy_code ||= detail_node.string('BldgOccupancy/NatureBusinessCd')\n            detail.assign_attributes({\n              interest_code:         detail_node.string('InterestCd'),\n              occupancy_code:        occupancy_code,\n              construction_code:     detail_node.string('Construction/ConstructionCd'),\n              roofing_code:          detail_node.string('Construction/RoofingMaterial/RoofMaterialCd'),\n              siding_code:           detail_node.string('Construction/SidingCd'),\n              glass_type_code:       detail_node.string('Construction/GlassTypeCd'),\n              wind_code:             detail_node.string('WindClassCd'),\n              water_proximity_code:  detail_node.string('SeacoastOrOtherBodyWaterProximityCd'),\n              protection_grade_code: detail_node.string('BldgProtection/ProtectionClassGradeCd'),\n              sprinklered_percent:   detail_node.string('BldgProtection/SprinkleredPct'),\n              number_of_stories:     detail_node.string('Construction/NumStories'),\n              number_of_units:       detail_node.string('Construction/NumUnits'),\n              year_built:            detail_node.string('Construction/YearBuilt'),\n              square_footage:        detail_node.string('Construction/BldgArea[UnitMeasurementCd=\"SQFT\"]/NumUnits'),\n              percent_occupied:      detail_node.string('BldgOccupancy/OccupiedPct'),\n              territory_code:        detail_node.string('TerritoryCd'),              \n            }, without_protection: true)\n            detail.save!(validate: false)\n          end\n\n          read_additional_interests(policy_version, building_node.array('AdditionalInterest'), building)\n\n          true\n        end # read_in_array buildings\n\n        true\n      end # read_in_array locations\n\n      # Using this block because the lob order won't always match the database\n      if vpi_mode\n        lobs = policy_version.lines_of_business.all.group_by{|lob| lob.short_name }\n        @lobs.each do |k, v|\n          if lob = lobs[k].try(:first)\n            lob.update_attributes!(premium: v)\n          end\n        end\n      else\n        policy_version.lines_of_business.each(&:destroy)\n        # need remove the deleted records from the association, the dead objects like to stick \n        # around until the association is reloaded\n        policy_version.lines_of_business.reload \n        @lobs.each do |k, v|\n          lob = policy_version.lines_of_business.build\n          lob.assign_attributes({\n            short_name: k, \n            premium: v,\n          }, without_protection: true)\n          lob.save!(validate: false)\n        end\n      end\n      \n      if policy_version.gl?\n        lob_node = @service_request.node('GeneralLiabilityLineBusiness[LOBCd=\"CGL\"]')\n        \n        limit_nodes = GlLimit::CODES.keys.map do |code|\n          amount = lob_node.string(\"LiabilityInfo/CommlCoverage[CoverageCd=\\\"#{code}\\\"]/Limit/FormatCurrencyAmt/Amt\")\n          [\n            code,\n            amount\n          ] if amount\n        end\n        limit_nodes.compact!\n        read_in_array(policy_version.gl_limits, limit_nodes) do |obj, code_amount|\n          {\n            code: code_amount.first,\n            amount: code_amount.second,\n          }\n        end\n\n        deductible_nodes = GlDeductible::APPLIES_TO_CODES.keys.map do |code|\n          # These are sometimes ALL present (Form CG0300) because of AIM limitations. Need to find only the ones with a value for VPB.\n          lob_node.node(\"LiabilityInfo/CommlCoverage[CoverageCd=\\\"GL\\\"]/Deductible[DeductibleAppliesToCd=\\\"#{code}\\\" and FormatCurrencyAmt/Amt/text()]\")\n        end\n        deductible_nodes.compact!\n        read_in_array(policy_version.gl_deductibles, deductible_nodes) do |deductible, node| \n          {\n            type_code:       node.string('DeductibleTypeCd'),\n            applies_to_code: node.string('DeductibleAppliesToCd'),\n            amount:          node.string('FormatCurrencyAmt/Amt'),\n          }\n        end\n\n        read_in_array(policy_version.gl_classifications, lob_node.array('LiabilityInfo/GeneralLiabilityClassification')) do |obj, node|\n          building = node.building_id && @buildings[node.building_id]\n          {\n            building_id:      building.try(:id),\n            code:             node.string('ClassCd'),\n            exposure:         node.string('Exposure'),\n            basis:            node.string('PremiumBasisCd'),\n            description:      node.string('ClassCdDesc'),\n            premises_rate:    node.string('CommlCoverage[CoverageCd=\"PREM\"]/Rate'),\n            premises_premium: node.string('CommlCoverage[CoverageCd=\"PREM\"]/CurrentTermAmt/Amt'),\n            product_rate:     node.string('CommlCoverage[CoverageCd=\"PRDCO\"]/Rate'),\n            product_premium:  node.string('CommlCoverage[CoverageCd=\"PRDCO\"]/CurrentTermAmt/Amt'),\n          }\n        end\n      else\n        policy_version.gl_deductibles.each(&:destroy)\n        policy_version.gl_limits.each(&:destroy)\n        policy_version.gl_classifications.each(&:destroy)\n      end\n\n      if policy_version.mpl?\n        lob_node = @service_request.node('ProfessionalLiabilityLineBusiness[LOBCd=\"PLMSC\"]')\n        \n        limit_nodes = MplLimit::CODES.keys.map do |code|\n          amount = lob_node.string(\"LiabilityInfo/CommlCoverage[CoverageCd=\\\"#{code}\\\"]/Limit/FormatCurrencyAmt/Amt\")\n          [\n            code,\n            amount\n          ] if amount\n        end\n        limit_nodes.compact!\n        read_in_array(policy_version.mpl_limits, limit_nodes) do |obj, code_amount|\n          {\n            code: code_amount.first,\n            amount: code_amount.second,\n          }\n        end\n\n        # Only read the first one here, leaving the array code in so it's easy to change out to multiple ones, like gl, later.\n        deductible_nodes = [lob_node.node(\"LiabilityInfo/CommlCoverage[CoverageCd=\\\"GENAG\\\"]/Deductible[1]\")]\n        read_in_array(policy_version.mpl_deductibles, deductible_nodes) do |deductible, node| \n          {\n            type_code:       node.string('DeductibleTypeCd'),\n            amount:          node.string('FormatCurrencyAmt/Amt'),\n          }\n        end\n\n        read_in_array(policy_version.mpl_classifications, lob_node.array('LiabilityInfo/ProfessionalLiabilityClassification')) do |obj, node|\n          building = node.building_id && @buildings[node.building_id]\n          {\n            building_id:      building.try(:id),\n            code:             node.string('ClassCd'),\n            exposure:         node.string('Exposure'),\n            basis:            node.string('PremiumBasisCd'),\n            description:      node.string('ClassCdDesc'),\n            premises_rate:    node.string('CommlCoverage[CoverageCd=\"PREM\"]/Rate'),\n            premises_premium: node.string('CommlCoverage[CoverageCd=\"PREM\"]/CurrentTermAmt/Amt'),\n          }\n        end\n      else\n        policy_version.mpl_deductibles.each(&:destroy)\n        policy_version.mpl_limits.each(&:destroy)\n        policy_version.mpl_classifications.each(&:destroy)\n      end\n\n      if policy_version.property?\n        policy_version.property_coverages.each(&:destroy) unless vpi_mode\n\n        lob_node = @service_request.node('CommlPropertyLineBusiness[LOBCd=\"PROPC\"]')\n        @buildings.each do |id, building|\n          if prop_node = lob_node.node(\"PropertyInfo/CommlPropertyInfo[@SubLocationRef=\\\"#{id}\\\"]\")\n            value = prop_node.string('ItemValueAmt/Amt')\n            classcd = prop_node.string('ClassCd')\n\n            if value || classcd\n              building.build_building_detail(policy_version: policy_version) unless building.building_detail\n              building.building_detail.assign_attributes({\n                value: value,\n                class_code: classcd,\n              }, without_protection: true)\n              building.building_detail.save!(validate: false)\n            end\n\n            read_in_array(\n              policy_version.property_coverages.where(building_id: building.try(:id)),\n              prop_node.array(\"CommlCoverage\"),\n              false\n            ) do |ar, node|\n              {\n                building_id:                building.id,\n                code:                       node.string('CoverageCd'),\n                premium:                    node.string('CurrentTermAmt/Amt'),\n                limit:                      node.string('Limit/FormatCurrencyAmt/Amt'),\n                deductible:                 node.string('Deductible[not(DeductibleAppliesToCd) or DeductibleAppliesToCd!=\"EQK\"]/FormatCurrencyAmt/Amt'),\n                rate:                       node.string('Rate'),\n                coinsurance_percent:        node.string('CommlCoverageSupplement/CoinsurancePct'),\n                valuation_code:             node.string('Limit/ValuationCd'),\n                covered_cause_of_loss_code: node.string('CommlCoverageSupplement/CoverageSubCd'),\n                indemnity_limit_code:       node.string('Option/OptionCd'),\n                earthquake_deductible:      node.string('Deductible[DeductibleAppliesToCd=\"EQK\"]/FormatPct'),\n              }\n            end\n          elsif building_detail = building.building_detail\n            building_detail.assign_attributes({\n              value: nil,\n              class_code: nil,\n            }, without_protection: true)\n            building_detail.save!(validate: false)\n          end\n        end\n      else\n        policy_version.property_coverages.each(&:destroy)\n      end\n\n      if policy_version.crime?\n        policy_version.crime_coverages.each(&:destroy) unless vpi_mode\n\n        lob_node = @service_request.node('CrimeLineBusiness[LOBCd=\"CRIME\"]')\n\n        read_in_array(policy_version.crime_coverages, lob_node.array(\"CrimeCoverageInfo[CrimePlanCd=\\\"PLAN1\\\"]\")) do |ar, node|\n          unless ar.persisted?\n            ar.building = @buildings[node.building_id]\n            ar.save!\n          end\n\n          xpath = \"CrimeCoverageDetails/CommlCoverage\"\n          read_in_array(ar.crime_coverage_details, node.array(xpath)) do |ar, node|\n            {\n              code:       node.string('CoverageCd'),\n              premium:    node.string('CurrentTermAmt/Amt'),\n              limit:      node.string('Limit/FormatCurrencyAmt/Amt'),\n              deductible: node.string('Deductible/FormatCurrencyAmt/Amt'),\n            }\n          end\n\n          nil\n        end\n      else\n        policy_version.crime_coverages.each(&:destroy)\n      end\n\n      if policy_version.inland_marine?\n        unless vpi_mode\n          policy_version.im_classes.each(&:destroy) \n          policy_version.im_schedule_items.each(&:destroy) \n        end\n\n        lob_node = @service_request.node('CommlInlandMarineLineBusiness[LOBCd=\"INMRC\"]')\n        read_in_array(policy_version.im_classes, lob_node.array(\"CommlIMInfo\")) do |ar, node|\n          class_info = ImClass.guess_short_name_from_codes(node.string(\"CommlIMClassCd\"), node.string(\"CommlCoverage[1]/CoverageCd\"))\n          xpath = class_info[:coverage_code] ? \"CommlCoverage[CoverageCd=\\\"#{class_info[:coverage_code]}\\\"]\" : \"CommlCoverage[not(CoverageCd)]\"\n          coverage_node = node.node(xpath)\n          ar.assign_attributes(\n            {\n              short_name: class_info[:short_name],\n              premium: node.string('CurrentTermAmt/Amt'),\n              rate: coverage_node.try(:string, \"Rate\"),\n              deductible: coverage_node.try(:string, \"Deductible[DeductibleTypeCd=\\\"CL\\\"]/FormatCurrencyAmt/Amt\"),\n              coinsurance_percent: coverage_node.try(:string, \"CommlCoverageSupplement/CoinsurancePct\"),\n            },\n            without_protection: true \n          )\n          arr = if class_info[:coverage_code]\n            coverage_node.array(\"Limit[LimitAppliesToCd]\")\n          else\n            node.array(\"CommlCoverage[CoverageCd]/Limit[LimitAppliesToCd]\")\n          end\n          # If coverage code\n          read_in_array(ar.im_limits, arr) do |arl, node|\n            h = ImLimit.guess_short_name_from_codes(\n              node.string(\"LimitAppliesToCd\"),\n              node.string(\"parent::node()/CoverageCd\"),\n              class_info[:coverage_code]\n            )\n            if h[:short_name].nil?\n              {amount: nil, policy_version_id: policy_version.id} # Utilizing the after_save callback on the model\n            else\n              {\n                code: h[:short_name],\n                amount: node.string(\"FormatCurrencyAmt/Amt\"),\n                policy_version_id: policy_version.id,\n                im_class_id: ar.id\n              }\n            end\n          end\n\n          arr = if class_info[:coverage_code]\n            coverage_node.array(\"Deductible[DeductibleTypeCd]\")\n          else\n            node.array(\"CommlCoverage[CoverageCd]/Deductible[DeductibleTypeCd]\")\n          end\n          read_in_array(ar.im_deductibles, arr) do |ard, node|\n            h = ImDeductible.guess_short_name_from_codes(\n              node.string(\"DeductibleTypeCd\"),\n              node.string(\"parent::node()/CoverageCd\"),\n              class_info[:coverage_code]\n            )\n            if h[:short_name].nil?\n              {amount: nil, policy_version_id: policy_version.id} # Utilizing the after_save callback on the model\n            else\n              {\n                code: h[:short_name],\n                amount: node.string(\"FormatCurrencyAmt/Amt\"),\n                policy_version_id: policy_version.id,\n                im_class_id: ar.id\n              }\n            end\n          end\n\n          # READ SCHEDULE HERE, CLASS INFO IS AVAILABLE\n          # Note about limit field vs im_limits table:\n          # If a Limit node has a LimitAppliesToCd, it goes in the im_limits table, \n          # if not, it is saved to the limit field on the im_schedule_items.\n          if ar.schedule?\n            info_node_xpath =  if class_info[:short_name] == \"trip_transit\"\n              \"TransportationInfo/TransportationDetail\"\n            elsif class_info[:short_name] == \"watercraft\"\n              \"TransportationInfo/CommlVeh\"\n            else\n              \"PropertySummaryInfo/PropertyItem/ItemDetail\"\n            end\n\n            read_in_array(ar.schedule, node.array(\"CommlIMPropertyInfo\")) do |ars, node|\n              info_node = node.node(info_node_xpath)\n              ars.assign_attributes(\n                {\n                  building:              @buildings[node.building_id],\n                  item_number:           info_node.try(:string, \"ItemIdInfo/AgencyId\"),\n                  item_type_code:        info_node.try(:string, \"ItemTypeCd\"),\n                  description:           node.string(\"PropertySummaryInfo/PropertyItem/ItemDetail/ItemDesc\"),\n                  limit:                 node.string(\"CommlCoverage/Limit[not(LimitAppliesToCd)]/FormatCurrencyAmt/Amt\"),\n                  premium:               node.string('PropertySummaryInfo/CurrentTermAmt/Amt') || node.string(\"CommlCoverage/CurrentTermAmt/Amt\"),\n                  rate:                  node.string(\"CommlCoverage/Rate\"),\n                  manufacturer:          info_node.try(:string, \"Manufacturer\"),\n                  model:                 info_node.try(:string, \"Model\"),\n                  model_year:            info_node.try(:string, \"ModelYear\"),\n                  serial_number:         info_node.try(:string, \"SerialIdNumber\") || info_node.try(:string, \"VehIdentificationNumber\"),\n                  valuation_code:        node.try(:string, \"CommlCoverage/Limit/ValuationCd\"),\n                  shipped_from_city:     info_node.try(:string, \"ShippingInfo/OriginDestinationInfo/Addr[AddrTypeCd='PointOfDepartureAddress']/City\"),\n                  shipped_from_state:    info_node.try(:string, \"ShippingInfo/OriginDestinationInfo/Addr[AddrTypeCd='PointOfDepartureAddress']/StateProvCd\"),\n                  shipped_to_city:       info_node.try(:string, \"ShippingInfo/OriginDestinationInfo/Addr[AddrTypeCd='PointOfDestinationAddress']/City\"),\n                  shipped_to_state:      info_node.try(:string, \"ShippingInfo/OriginDestinationInfo/Addr[AddrTypeCd='PointOfDestinationAddress']/StateProvCd\"),\n                  from_date:             node.try(:string, \"CommlCoverage/EffectiveDt\") || info_node.try(:string, \"ShipStartDt\"),\n                  to_date:               node.try(:string, \"CommlCoverage/ExpirationDt\") || info_node.try(:string, \"ShipEndDt\"),\n                  lettering:             info_node.try(:string, \"ManufactureMethodCd\"),\n                },\n                without_protection: true \n              )\n\n              if ars.respond_to?(:limit_codes)\n                arr = node.array(\"CommlCoverage/Limit[LimitAppliesToCd]\")\n                read_in_array(ars.im_limits, arr) do |aa, node|\n                  h = ImLimit.guess_short_name_from_codes(\n                      node.string(\"LimitAppliesToCd\"),\n                      node.string(\"parent::node()/CoverageCd\"),\n                      class_info[:coverage_code]\n                    )\n                  if ars.limit_codes.include? h[:short_name]\n                    {\n                      amount: node.string(\"FormatCurrencyAmt/Amt\"),\n                      code: h[:short_name],\n                      policy_version_id: policy_version.id,\n                      im_schedule_item_id: ars.id\n                    }\n                  else\n                    {amount: nil, policy_version_id: policy_version.id} # Utilizing the after_save callback on the model\n                  end\n                end\n              end\n\n              if ars.respond_to?(:deductible_codes)\n                arr = node.array(\"CommlCoverage/Deductible\")\n                read_in_array(ars.im_deductibles, arr) do |aa, node|\n                  h = ImDeductible.guess_short_name_from_codes(\n                      node.string(\"DeductibleTypeCd\"),\n                      node.string(\"parent::node()/CoverageCd\"),\n                      class_info[:coverage_code]\n                    )\n                  if ars.deductible_codes.include? h[:short_name]\n                    {\n                      amount: node.string(\"FormatCurrencyAmt/Amt\"),\n                      code: h[:short_name],\n                      policy_version_id: policy_version.id,\n                      im_schedule_item_id: ars.id\n                    }\n                  else\n                    {amount: nil, policy_version_id: policy_version.id} # Utilizing the after_save callback on the model\n                  end\n                end\n              end\n            end\n\n            nil\n          end #read_in_array\n\n          read_in_array(policy_version.im_ar_receptacles, @service_request.array(\"CommlSubLocation/SafeVaultCharacteristics[ItemInfo/ItemIdInfo/OtherIdentifier='AR']\")) do |ar, node|\n            building = @buildings[node.node(\"parent::node()\").try(:building_id)]\n            {\n              building: building, \n              item_type_code:        node.string(\"ItemInfo/ItemDefinition/ItemTypeCd\"),\n              manufacturer:          node.string(\"ItemInfo/ItemDefinition/Manufacturer\"),\n              label_code:            node.string(\"LabelInfo\"),\n              safe_vault_class_code: node.string(\"SafeVaultClassCd\"),\n              issuer:                node.string(\"LabelCd\"),\n            }\n          end\n\n          read_in_array(policy_version.im_vp_receptacles, @service_request.array(\"CommlSubLocation/SafeVaultCharacteristics[ItemInfo/ItemIdInfo/OtherIdentifier='VP']\")) do |ar, node|\n            building = @buildings[node.node(\"parent::node()\").try(:building_id)]\n            {\n              building: building, \n              item_type_code:        node.string(\"ItemInfo/ItemDefinition/ItemTypeCd\"),\n              manufacturer:          node.string(\"ItemInfo/ItemDefinition/Manufacturer\"),\n              label_code:            node.string(\"LabelInfo\"),\n              safe_vault_class_code: node.string(\"SafeVaultClassCd\"),\n              issuer:                node.string(\"LabelCd\"),\n            }\n          end\n\n          read_in_array(policy_version.im_exhibition_receptacles, @service_request.array(\"CommlSubLocation[ContractEffectiveDt]\")) do |ar, node|\n            building = @buildings[node.try(:building_id)]\n            puts \"#{building.inspect}\"\n            {\n              building: building, \n              from_date:        node.string(\"ContractEffectiveDt\"),\n              to_date:          node.string(\"ContractExpirationDt\"),\n            }\n          end\n\n        end# inland_marine?\n\n      end\n\n    end\n\n\n    policy.reload\n  end\n\n  class << self\n    def schema\n      @@schema ||= begin\n        schema = File.read(File.join(Rails.root, 'config', 'schemas', 'acord.xsd'))\n        options = Nokogiri::XML::ParseOptions::STRICT | (Nokogiri::XML::ParseOptions::NONET & Nokogiri::XML::ParseOptions::DTDLOAD)\n        doc = Nokogiri::XML::Document.parse(schema, nil, nil, options)\n        Nokogiri::XML::Schema.from_document(doc)\n      end\n    end\n  end\n\n  def xml_errors?\n    xml_errors.present?\n  end  \n\n  private\n\n  def read_additional_interests(policy, xml_node_array, building=nil)\n    read_in_array(\n      policy.additional_interests.where(building_id: building.try(:id)),\n      xml_node_array\n    ) do |obj, node|\n      obj.assign_attributes({\n        building: building,\n        role:  node.string('AdditionalInterestInfo/NatureInterestCd'),\n        name:  node.string('GeneralPartyInfo/NameInfo/CommlName/CommercialName'),\n        phone: node.string('GeneralPartyInfo/Communications/PhoneInfo[PhoneTypeCd=\"Phone\"]/PhoneNumber'),\n        email: node.string('GeneralPartyInfo/Communications/EmailInfo/EmailAddr'),\n      }, without_protection: true)\n      obj.save!(validate: false)\n      set_mailing_address(obj, node.address('GeneralPartyInfo'))\n    end\n  end\n\n  def set_mailing_address(object, attributes)\n    object.build_mailing_address unless object.mailing_address\n    object.mailing_address.assign_attributes(attributes, without_protection: true)\n    object.mailing_address.save!(validate: false)\n  end\n\n  def read_in_array(relation, nodes, skip_delete=nil, &block)\n    arr = unless @vpi_mode\n      relation.each(&:destroy) unless skip_delete\n      nodes.map{|node| [relation.build, node] }\n    else\n      e = nodes.to_enum\n      relation.map{|obj| [obj, e.next] }\n    end\n    arr.each do |obj, node|\n      r = yield(obj, node)\n      if r.is_a?(Hash)\n        obj.assign_attributes(r, without_protection: true) unless obj.destroyed?\n      end\n      obj.save!(validate: false) #rescue ActiveRecord::StatementInvalid\n    end\n  end\n\n  def validate_xml\n    @xml_errors = []\n    self.class.schema.validate(@xml).each do |error|\n      @xml_errors << error.to_s\n    end\n    @xml_errors.empty?\n  end\n\n  def error!(message)\n    raise Acord::Exceptions::UnsupportedPolicy, message\n  end\n\nend\nend","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":75,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/davidtakahashi/policy_builder/app/lib/acord/policy_reader.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1d041333aeabb07596b1b358d69b73d3d3ae1837","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":61,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":62,"softWrap":false,"editorWidthInChars":186,"tokenizedBuffer":{"bufferPath":"/Users/davidtakahashi/policy_builder/app/views/builder/im_trip_transit.html.haml","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":69,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":70,"softWrap":false,"editorWidthInChars":189,"tokenizedBuffer":{"bufferPath":"/Users/davidtakahashi/policy_builder/app/views/builder/im_contractors_equipment.html.haml","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":75,"softTabs":true,"scrollTop":12480,"scrollLeft":0,"displayBuffer":{"id":76,"softWrap":false,"editorWidthInChars":189,"tokenizedBuffer":{"bufferPath":"/Users/davidtakahashi/policy_builder/app/lib/acord/policy_reader.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":71,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":72,"softWrap":false,"editorWidthInChars":189,"tokenizedBuffer":{"bufferPath":"/Users/davidtakahashi/policy_builder/app/models/im_class.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":73,"softTabs":true,"scrollTop":1560,"scrollLeft":0,"displayBuffer":{"id":74,"softWrap":false,"editorWidthInChars":189,"tokenizedBuffer":{"bufferPath":"/Users/davidtakahashi/policy_builder/app/models/im_limit.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/davidtakahashi/policy_builder/app/views/builder/im_trip_transit.html.haml","focused":false,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/davidtakahashi/policy_builder/app/views/builder/im_trip_transit.html.haml":1395336619786,"/Users/davidtakahashi/policy_builder/app/views/builder/im_contractors_equipment.html.haml":1395272373821,"/Users/davidtakahashi/policy_builder/app/lib/acord/policy_reader.rb":1395272533773,"/Users/davidtakahashi/policy_builder/app/models/im_class.rb":1395272623189,"/Users/davidtakahashi/policy_builder/app/models/im_limit.rb":1395334045410},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":11561087},"tree-view":{"directoryExpansionStates":{},"selectedPath":"/Users/davidtakahashi/policy_builder/app","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}